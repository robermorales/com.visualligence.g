/*
* generated by Xtext
*/

package com.visualligence.g.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class VMLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModuleAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cTypesKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypesTypeDeclParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cInputKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInputAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInputInputParserRuleCall_2_1_0 = (RuleCall)cInputAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cOutputKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cOutputAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOutputOutputParserRuleCall_3_1_0 = (RuleCall)cOutputAssignment_3_1.eContents().get(0);
		
		////generate vML "http://www.visualligence.com/g/VML"
		//// @TODO syntax coloring for numeric terminals
		//// @TODO revisar tuplas !!! tupla vac√≠a??? (: a:a, a:b )
		//// @TODO genericidad en los tipos
		//// @TODO Nombre con estilo Java y paquetes. imprescindible para crecer.
		//Module:
		//	{Module} ("types" types+=TypeDecl)* ("input" input+=Input)* ("output" output+=Output)*;
		public ParserRule getRule() { return rule; }

		//{Module} ("types" types+=TypeDecl)* ("input" input+=Input)* ("output" output+=Output)*
		public Group getGroup() { return cGroup; }

		//{Module}
		public Action getModuleAction_0() { return cModuleAction_0; }

		//("types" types+=TypeDecl)*
		public Group getGroup_1() { return cGroup_1; }

		//"types"
		public Keyword getTypesKeyword_1_0() { return cTypesKeyword_1_0; }

		//types+=TypeDecl
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }

		//TypeDecl
		public RuleCall getTypesTypeDeclParserRuleCall_1_1_0() { return cTypesTypeDeclParserRuleCall_1_1_0; }

		//("input" input+=Input)*
		public Group getGroup_2() { return cGroup_2; }

		//"input"
		public Keyword getInputKeyword_2_0() { return cInputKeyword_2_0; }

		//input+=Input
		public Assignment getInputAssignment_2_1() { return cInputAssignment_2_1; }

		//Input
		public RuleCall getInputInputParserRuleCall_2_1_0() { return cInputInputParserRuleCall_2_1_0; }

		//("output" output+=Output)*
		public Group getGroup_3() { return cGroup_3; }

		//"output"
		public Keyword getOutputKeyword_3_0() { return cOutputKeyword_3_0; }

		//output+=Output
		public Assignment getOutputAssignment_3_1() { return cOutputAssignment_3_1; }

		//Output
		public RuleCall getOutputOutputParserRuleCall_3_1_0() { return cOutputOutputParserRuleCall_3_1_0; }
	}

	public class TypeDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cHashParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//TypeDecl:
		//	"type" Hash name=STRING;
		public ParserRule getRule() { return rule; }

		//"type" Hash name=STRING
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//Hash
		public RuleCall getHashParserRuleCall_1() { return cHashParserRuleCall_1; }

		//name=STRING
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0() { return cNameSTRINGTerminalRuleCall_2_0; }
	}

	public class HashElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Hash");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHashAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cItemsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cItemsHashItemParserRuleCall_2_0_0 = (RuleCall)cItemsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cItemsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cItemsHashItemParserRuleCall_2_1_1_0 = (RuleCall)cItemsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Hash:
		//	{Hash} "{" (items+=HashItem ("," items+=HashItem)*)? "}";
		public ParserRule getRule() { return rule; }

		//{Hash} "{" (items+=HashItem ("," items+=HashItem)*)? "}"
		public Group getGroup() { return cGroup; }

		//{Hash}
		public Action getHashAction_0() { return cHashAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(items+=HashItem ("," items+=HashItem)*)?
		public Group getGroup_2() { return cGroup_2; }

		//items+=HashItem
		public Assignment getItemsAssignment_2_0() { return cItemsAssignment_2_0; }

		//HashItem
		public RuleCall getItemsHashItemParserRuleCall_2_0_0() { return cItemsHashItemParserRuleCall_2_0_0; }

		//("," items+=HashItem)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//items+=HashItem
		public Assignment getItemsAssignment_2_1_1() { return cItemsAssignment_2_1_1; }

		//HashItem
		public RuleCall getItemsHashItemParserRuleCall_2_1_1_0() { return cItemsHashItemParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class HashItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HashItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHashItemAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTypeTypeDeclCrossReference_3_0 = (CrossReference)cTypeAssignment_3.eContents().get(0);
		private final RuleCall cTypeTypeDeclIDTerminalRuleCall_3_0_1 = (RuleCall)cTypeTypeDeclCrossReference_3_0.eContents().get(1);
		
		//HashItem:
		//	{HashItem} name=STRING ":" type=[TypeDecl];
		public ParserRule getRule() { return rule; }

		//{HashItem} name=STRING ":" type=[TypeDecl]
		public Group getGroup() { return cGroup; }

		//{HashItem}
		public Action getHashItemAction_0() { return cHashItemAction_0; }

		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=[TypeDecl]
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//[TypeDecl]
		public CrossReference getTypeTypeDeclCrossReference_3_0() { return cTypeTypeDeclCrossReference_3_0; }

		//ID
		public RuleCall getTypeTypeDeclIDTerminalRuleCall_3_0_1() { return cTypeTypeDeclIDTerminalRuleCall_3_0_1; }
	}

	public class InputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Input");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeTypeDeclCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeTypeDeclIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeTypeDeclCrossReference_2_0.eContents().get(1);
		
		//Input:
		//	name=STRING ":" type=[TypeDecl];
		public ParserRule getRule() { return rule; }

		//name=STRING ":" type=[TypeDecl]
		public Group getGroup() { return cGroup; }

		//name=STRING
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0() { return cNameSTRINGTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=[TypeDecl]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//[TypeDecl]
		public CrossReference getTypeTypeDeclCrossReference_2_0() { return cTypeTypeDeclCrossReference_2_0; }

		//ID
		public RuleCall getTypeTypeDeclIDTerminalRuleCall_2_0_1() { return cTypeTypeDeclIDTerminalRuleCall_2_0_1; }
	}

	public class OutputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Output");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeTypeDeclCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeTypeDeclIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeTypeDeclCrossReference_2_0.eContents().get(1);
		
		/// *
		//Module:
		//	{Module}
		//	( 'module'   name       = ID       )?
		//	( 'input'    inputtype  = TypeRef  )?
		//	( 'output'   outputtype = TypeRef  )?
		//	( 'author'   author     = STRING   )?
		//	( 'creation' creation   = STRING   )?
		//	( 'more'     link       = STRING   )?
		//	
		//	imports   += Import*
		//
		//	sentences += Sentence*
		//;
		//
		//Import:
		//	'import'
		//	importURI = STRING
		//;
		//
		//Sentence:
		//	Multi     |
		//	Unit      |
		//	Box       |
		//	Constant  |
		//	Shape     |
		//	TypeAlias |
		//	Node      |
		//	Stream    |
		//	Canvas    |
		//
		//	Block     |
		//
		//	Noop
		//;
		//
		//Node:
		//	Invokation  |
		//	Factory     |
		//	Loop        |
		//	Switch      |
		//	File
		//;
		//
		//Switch:
		//	'switch'
		//	name = ID
		//	test = LiteralExpression
		//	'?'
		//	a = LiteralExpression
		//	':'
		//	b = LiteralExpression
		//;
		//
		//LiteralExpression:
		//	LiteralExpressionBin
		//;
		//
		//LiteralExpressionBin returns LiteralExpression:
		//	LiteralExpressionComp
		//	(
		//		{Operation.left=current}
		//		op    = BinOp
		//		right = LiteralExpressionBin
		//	)?
		//;
		//
		//LiteralExpressionComp returns LiteralExpression:
		//	LiteralExpressionAdd
		//	(
		//		{Operation.left=current}
		//		op    = CompOp
		//		right = LiteralExpressionComp
		//	)?
		//;
		//
		//LiteralExpressionAdd returns LiteralExpression:
		//	LiteralExpressionMulti
		//	(
		//		{Operation.left=current}
		//		op    = AddOp
		//		right = LiteralExpressionAdd
		//	)?
		//;
		//
		//LiteralExpressionMulti returns LiteralExpression:
		//	LiteralExpressionExp
		//	(
		//		{Operation.left=current}
		//		op    = MultiOp
		//		right = LiteralExpressionMulti	
		//	)?
		//;
		//
		//LiteralExpressionExp returns LiteralExpression:
		//	LiteralExpressionSigned
		//	(
		//		{Operation.left=current}
		//		op    = ExpOp
		//		right = LiteralExpressionExp
		//	)?
		//;
		//
		//LiteralExpressionSigned returns LiteralExpression:
		//	(
		//		{UnaryOperation}
		//		op    = ( AddOp | NegationOp )
		//		right = LiteralExpressionTerminal
		//	)|
		//	LiteralExpressionTerminal
		//;
		//
		//LiteralExpressionTerminal returns LiteralExpression:
		//	(
		//		'(' LiteralExpression ')' |
		//		RValue
		//	)
		//;
		//
		//enum BinOp returns Op:
		//	and = '&&' |
		//	or  = '||'
		//;
		//
		//enum NegationOp returns Op:
		//	neg = '!'
		//;
		//
		//enum CompOp returns Op:
		//	eq = '==' |
		//	ne = '!=' |
		//	lt = '<'  |
		//	gt = '>'  |
		//	le = '<=' |
		//	ge = '>='
		//;
		//
		//enum AddOp returns Op:
		//	plus  = '+' |
		//	minus = '-'
		//;
		//
		//enum MultiOp returns Op:
		//	times       = '*'  |
		//	modulo      = '%'  |
		//	intdivision = '//' |
		//	divideby    = '/'
		//;
		//
		//enum ExpOp returns Op:
		//	exp = '**'
		//;
		//
		//RValue:
		//	SingleLiteral   |
		//	SequenceLiteral |
		//	TupleLiteral    |
		//
		////	NodeRef         |
		////	MemberRef       |
		//	ConstantRef
		//;
		//
		//NodeRef:
		//	node = [Node|ID]
		//;
		//
		//MemberRef:
		////	(
		////		node = [Node|ID]
		////		'.'
		////	)?
		//	member = [LoopSentence|ID]
		//;
		//
		//ConstantRef:
		//	constantref = [Constant|ID]
		//;
		//
		//SingleLiteral:
		//	value = SingleLiteralDT
		//;
		//
		//SingleLiteralDT:
		//	BoolLiteral   |
		//	NumberLiteral |
		//	StringLiteral
		//;
		//
		//StringLiteral:
		//	STRING
		//;
		//
		//NumberLiteral:
		//	Integer   |
		//	Float     |
		//	SNotation |
		//	Imaginary
		//;
		//
		//Integer:
		//	INT |
		//	OCT |
		//	HEX |
		//	BIN
		//;
		//
		//Float:
		//	( INT '.' INT? )
		//	|
		//	( '.' INT )
		//;
		//
		//SNotation:
		//	( INT | Float )
		//	ExpConstant
		//	Sign?
		//	INT
		//;
		//
		//ExpConstant: 'e' | 'E' ;
		//
		//Sign: '+' | '-';
		//
		//Imaginary:
		//	( INT | Float )?
		//	ImaginaryConstant
		//;
		//
		//ImaginaryConstant: 'i' | 'j';
		//
		//BoolLiteral: 'true' | 'false';
		//
		//SequenceLiteral:
		//	SequenceLiteralPlain |
		//	SequenceLiteralSerie
		//;
		//
		//SequenceLiteralSerie:
		//	'[..'
		//		init = LiteralExpression
		//		'->'
		//		end  = LiteralExpression
		//		(
		//			','
		//			inc  = LiteralExpression
		//		)?
		//	']'
		//;
		//
		//SequenceLiteralPlain:
		//	{SequenceLiteralPlain}
		//	'['
		//		(
		//			items += LiteralExpression
		//			( ',' items += LiteralExpression )*
		//		)?
		//	']'
		//;
		//
		//TupleLiteral:
		//	{TupleLiteral}
		//	'('
		//		(
		//			items += TupleItem
		//			( ',' items += TupleItem )*
		//		)?
		//	')'
		//;
		//
		//TupleItem:
		//	name  = ID
		//	':'
		//	value = LiteralExpression
		//;
		//
		////terminal DEC returns ecore::EInt:     ('0'..'9')                  +;
		//terminal OCT returns ecore::EInt:     ('0'..'7')                  + 'o';
		//terminal HEX returns ecore::EInt: '0x'('0'..'9'|'A'..'F'|'a'..'f')+    ;
		//terminal BIN returns ecore::EInt:     ('0'..'1')                  + 'b';
		//
		//Block:
		//	{Block}
		//	'{'
		//		( '~' name = ID )?
		//		sentences += Sentence*
		//	'}'
		//;
		//
		//Noop:
		//	{Noop}
		//	name = 'noop'
		//;
		//
		//Pair:
		//	name  = ID
		//	'='
		//	value = STRING
		//;
		//
		//Constant:
		//	'constant'
		//	name  = ID
		//	type  = TypeRef
		//	'='
		//	value = LiteralExpression
		//;
		//
		//Multi:
		//	'multi'
		//	name     = ID
		//	'='
		//	op       = MultiOp?
		//	factor   = INT
		//	parent   = [Multi|ID]?
		//;
		//
		//Unit:
		//	DUnit |
		//	NUnit
		//;
		//
		//DUnit:
		//	'unit'
		//	name     = ID
		//	'='
		//	op       = MultiOp?
		//	factor   = INT
		//	multi    = [Multi|ID]?
		//	parent   = [Unit|ID]
		//;
		//
		//NUnit:
		//	'unit'
		//	name       = ID
		//	numbertype = NumberType
		//;
		//
		//Box:
		//	'box' name=ID
		//	'{'
		//		members += Member*
		//	'}'
		//;
		//
		//Shape:
		//	'shape'
		//	name = ID
		//;
		//
		//Member:
		//	name = ID
		//	type = TypeRef
		//;
		//
		//TypeRef:
		//	PlainTypeRef     |
		//	CompositeTypeRef
		//;
		//
		//PlainTypeRef:
		//	VoidTypeRef       |
		//	AutoTypeRef       |
		//	NumberTypeRef     |
		//	VisualTypeRef     |
		//	AuxTypeRef        |
		//	TypeAliasRef      |
		//	ShapeRef          |
		//	BoxRef            |
		//	UnitRef           |
		//	CollectionRef
		//;
		//
		//CompositeTypeRef:
		//	SequenceTypeRef   |
		//	TupleTypeRef      |
		//	SetTypeRef
		//;
		//
		//SequenceTypeRef:
		//	{SequenceTypeRef}
		//	'['
		//		type = TypeRef
		//	']'
		//;
		//
		//TupleTypeRef:
		//	{TupleTypeRef}
		//	'('
		//		(
		//			items += TupleTypeRefItem
		//			( ',' items += TupleTypeRefItem )*
		//		)?
		//	')'
		//;
		//
		//TupleTypeRefItem:
		//	name = ID
		//	':'
		//	type = TypeRef
		//;
		//
		//SetTypeRef:
		//	{SetTypeRef}
		//	'{'
		//		type = TypeRef
		//	'}'
		//;
		//
		//VoidTypeRef:
		//	name = 'void'
		//;
		//
		//AutoTypeRef:
		//	{AutoTypeRef}
		//	'auto'
		//;
		//
		//CollectionRef:
		//	collection = CollectionType '<' typeref = TypeRef '>'
		//;
		//
		//UnitRef:
		//	'in' unittype = [Unit|ID]
		//;
		//
		//BoxRef:
		//	'->' ref = [Box|ID]
		//;
		//
		//TypeAliasRef:
		//	ref = [TypeAlias|ID]
		//;
		//
		//AuxTypeRef:
		//	ref = AuxType
		//;
		//
		//ShapeRef:
		//	'~>' ref = [Shape|ID]
		//;
		//
		//NumberTypeRef:
		//	ref = NumberType
		//;
		//
		//VisualTypeRef:
		//	ref = VisualType
		//;
		//
		//enum NumberType:
		//	positive |
		//	natural  |
		//	integer  |
		//	rational
		//;
		//
		//enum VisualType:
		//	shape      |
		//	color      |
		//	angle      |
		//	size       |
		//	position   |
		//	texture
		//;
		//
		//enum AuxType :
		//	string     |
		//	bool
		//;
		//
		//TypeAlias:
		//	'alias'
		//	name = ID
		//	type = TypeRef
		//;
		//
		//enum CollectionType:
		//	set     |
		//	bag     |
		//	list    |
		//	graph   |
		//	single //trees, graphs, heaps, queues, stacks, ...?
		//;
		//
		//Stream:
		//	( name = 'stream' )?
		//	left = LStreamValue
		//	'<-'
		//	right = RStreamValue
		//;
		//
		//LStreamValue:
		//	OutputRef
		//;
		//
		//RStreamValue:
		//	InputRef         |
		//	LiteralExpression
		//;
		//
		//InputRef:
		//	{InputRef}
		//	'I'
		//;
		//
		//OutputRef:
		//	{OutputRef}
		//	'O'
		//;
		//
		//Invokation:
		//	module = ID//Module
		//	name = ID
		//	'{'
		//		( sentences += InvokationParam )*
		//	'}'
		//;
		//
		//InvokationParam:
		//	name = ID
		//	'<-'
		//	source = LiteralExpression
		//;
		//
		//Loop:
		//	'loop' 	
		//	it = (
		//		LoopFor
		//	)?
		//	name = ID
		//	'{'
		//		( sentences += LoopSentence )*
		//	'}'
		//;
		//
		//LoopSentence:
		//	name = ID
		//	type = TypeRef
		//	'<-'
		//	o = LiteralExpression
		//	(
		//		'<-'
		//		i = LiteralExpression
		//	)?
		//;
		//
		//LoopFor:
		//	( 'for' SequenceLiteral )
		//;
		//
		//Factory:
		//	'factory'
		//	name = ID
		//	type = TypeRef
		//;
		//
		//File:
		//	'file'
		//	name = ID
		//	(
		//		( isinput ?= '<-' ) |
		//		'->'
		//	)
		//	path = STRING
		//;
		//
		//Canvas:
		//	'canvas'
		//	name = ID
		//	'{'
		//		( properties += Pair ';' )*
		//	'}'
		//;
		// * / //terminal ID: ('a'..'z'|'A'..'Z');
		////terminal DATE: ('0'..'9')('0'..'9')('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9');
		////enum eConstant:
		////	PI   |
		////	G    |
		////	e    |
		////	A    |
		////	
		////	zero
		////;
		////
		////enum DecimalUpMulti:
		////	I    |//24
		////	Z    |//21
		////	E    |//18
		////	P    |//15
		////	T    |//12
		////	G    |//9
		////	M    |//6
		////	K    |//3
		////	H    |//2
		////	D    |//1
		////	
		////	regular
		////;
		////	
		////enum DecimalDownMulti:
		////	d    |//-1
		////	c    |//-2
		////	m    |//-3
		////	u    |//-6 ¬µ
		////	n    |//-9
		////	p    |//-12
		////	f    |//-15
		////	a    |//-18
		////	z    |//-21
		////	y    |//-24
		////
		////	regular
		////;
		////
		////enum NonDecimalMulti:
		////	dozen      |//12
		////	twelve     |//12
		////	sixty      |//60
		////	twentyfour |//24
		////	
		////	regular
		////;
		////
		////enum TimeDerivedUnits:
		////	minute    |
		////	hour      |
		////	day       |
		////	month     |
		////	year      |
		////	century   |
		////	millenium
		////;
		////
		////enum eUnit:
		////	second |
		////	meter  |
		////	gram   |
		////	newton |
		////	joule  |
		////	watt   |
		////	rad    |
		////	kelvin |
		////	
		////	units
		////;
		////
		////enum
		////	time    |
		////	date    |
		////	duration|
		////	
		////	geopos  |
		////	
		////	auto
		////;
		////
		////Source:
		////	'source' name=ID
		////	'{'
		////		( properties += Pair ';' )*
		////	'}'
		////;
		////
		////SourceRef:
		////	'^' ref=[Source|ID]
		////;
		////Model:
		////	(imports += Import)*
		////	(elements += Invokation)*
		////;
		////	
		////Import:
		////	'import' name=ID ';'
		////;
		////
		////Invokation:
		////	name=ID '(' (pars += Par)* ')'
		////;
		////
		////Par:
		////	value=STRING
		////;
		////
		////Program :
		////		'main' name = VARNAME content = Block
		////;
		////
		////Block :
		////		'{' ( sentences += Sentence )+ '}' |
		////		Sentence
		////;
		////
		////Sentence : ( Var | Asg | Print ) ';' ;
		////
		////Var : 'var' name = VARNAME ( init ?= '=' content = Exp ) ?;
		////
		////Asg : left = [Var] '=' right = Exp;
		////
		////Print : 'print' Exp;
		////
		////Exp :
		////		'(' includes = Exp ')'
		////;
		////
		////BinExp returns Exp :
		////		left = Exp operator = sumop right = Exp
		////;
		////
		////LitExp returns Exp :
		////		ref = VARNAME |
		////		val = INTEGER
		////;
		////
		////enum sumop returns BinOperator:
		////		ADD = '+' |
		////		SUB = '-'
		////;
		////		
		////enum mulop returns BinOperator:
		////		MUL = '*' |
		////		DIV = '/' |
		////		MOD = '%'
		////;
		////
		////terminal VARNAME : ('a'..'z')('a'..'z'|'_'|'0'..'9')*;
		////
		////terminal INTEGER : ('0'..'9') + ;
		////
		//////enum monop returns Op:
		//////		INV = '-' | INV = 'inv' |
		//////		LN  = '~' | LN  = 'ln'
		//////;
		////
		////// terminal FLOAT returns ecore::EFloat : INT '.' UINT? ( ( 'e' | 'E' ) INT )? ;
		////
		////
		////	
		//Output:
		//	name=STRING ":" type=[TypeDecl];
		public ParserRule getRule() { return rule; }

		//name=STRING ":" type=[TypeDecl]
		public Group getGroup() { return cGroup; }

		//name=STRING
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0() { return cNameSTRINGTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=[TypeDecl]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//[TypeDecl]
		public CrossReference getTypeTypeDeclCrossReference_2_0() { return cTypeTypeDeclCrossReference_2_0; }

		//ID
		public RuleCall getTypeTypeDeclIDTerminalRuleCall_2_0_1() { return cTypeTypeDeclIDTerminalRuleCall_2_0_1; }
	}
	
	
	private ModuleElements pModule;
	private TypeDeclElements pTypeDecl;
	private HashElements pHash;
	private HashItemElements pHashItem;
	private InputElements pInput;
	private OutputElements pOutput;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public VMLGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.visualligence.g.VML".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////generate vML "http://www.visualligence.com/g/VML"
	//// @TODO syntax coloring for numeric terminals
	//// @TODO revisar tuplas !!! tupla vac√≠a??? (: a:a, a:b )
	//// @TODO genericidad en los tipos
	//// @TODO Nombre con estilo Java y paquetes. imprescindible para crecer.
	//Module:
	//	{Module} ("types" types+=TypeDecl)* ("input" input+=Input)* ("output" output+=Output)*;
	public ModuleElements getModuleAccess() {
		return (pModule != null) ? pModule : (pModule = new ModuleElements());
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	//TypeDecl:
	//	"type" Hash name=STRING;
	public TypeDeclElements getTypeDeclAccess() {
		return (pTypeDecl != null) ? pTypeDecl : (pTypeDecl = new TypeDeclElements());
	}
	
	public ParserRule getTypeDeclRule() {
		return getTypeDeclAccess().getRule();
	}

	//Hash:
	//	{Hash} "{" (items+=HashItem ("," items+=HashItem)*)? "}";
	public HashElements getHashAccess() {
		return (pHash != null) ? pHash : (pHash = new HashElements());
	}
	
	public ParserRule getHashRule() {
		return getHashAccess().getRule();
	}

	//HashItem:
	//	{HashItem} name=STRING ":" type=[TypeDecl];
	public HashItemElements getHashItemAccess() {
		return (pHashItem != null) ? pHashItem : (pHashItem = new HashItemElements());
	}
	
	public ParserRule getHashItemRule() {
		return getHashItemAccess().getRule();
	}

	//Input:
	//	name=STRING ":" type=[TypeDecl];
	public InputElements getInputAccess() {
		return (pInput != null) ? pInput : (pInput = new InputElements());
	}
	
	public ParserRule getInputRule() {
		return getInputAccess().getRule();
	}

	/// *
	//Module:
	//	{Module}
	//	( 'module'   name       = ID       )?
	//	( 'input'    inputtype  = TypeRef  )?
	//	( 'output'   outputtype = TypeRef  )?
	//	( 'author'   author     = STRING   )?
	//	( 'creation' creation   = STRING   )?
	//	( 'more'     link       = STRING   )?
	//	
	//	imports   += Import*
	//
	//	sentences += Sentence*
	//;
	//
	//Import:
	//	'import'
	//	importURI = STRING
	//;
	//
	//Sentence:
	//	Multi     |
	//	Unit      |
	//	Box       |
	//	Constant  |
	//	Shape     |
	//	TypeAlias |
	//	Node      |
	//	Stream    |
	//	Canvas    |
	//
	//	Block     |
	//
	//	Noop
	//;
	//
	//Node:
	//	Invokation  |
	//	Factory     |
	//	Loop        |
	//	Switch      |
	//	File
	//;
	//
	//Switch:
	//	'switch'
	//	name = ID
	//	test = LiteralExpression
	//	'?'
	//	a = LiteralExpression
	//	':'
	//	b = LiteralExpression
	//;
	//
	//LiteralExpression:
	//	LiteralExpressionBin
	//;
	//
	//LiteralExpressionBin returns LiteralExpression:
	//	LiteralExpressionComp
	//	(
	//		{Operation.left=current}
	//		op    = BinOp
	//		right = LiteralExpressionBin
	//	)?
	//;
	//
	//LiteralExpressionComp returns LiteralExpression:
	//	LiteralExpressionAdd
	//	(
	//		{Operation.left=current}
	//		op    = CompOp
	//		right = LiteralExpressionComp
	//	)?
	//;
	//
	//LiteralExpressionAdd returns LiteralExpression:
	//	LiteralExpressionMulti
	//	(
	//		{Operation.left=current}
	//		op    = AddOp
	//		right = LiteralExpressionAdd
	//	)?
	//;
	//
	//LiteralExpressionMulti returns LiteralExpression:
	//	LiteralExpressionExp
	//	(
	//		{Operation.left=current}
	//		op    = MultiOp
	//		right = LiteralExpressionMulti	
	//	)?
	//;
	//
	//LiteralExpressionExp returns LiteralExpression:
	//	LiteralExpressionSigned
	//	(
	//		{Operation.left=current}
	//		op    = ExpOp
	//		right = LiteralExpressionExp
	//	)?
	//;
	//
	//LiteralExpressionSigned returns LiteralExpression:
	//	(
	//		{UnaryOperation}
	//		op    = ( AddOp | NegationOp )
	//		right = LiteralExpressionTerminal
	//	)|
	//	LiteralExpressionTerminal
	//;
	//
	//LiteralExpressionTerminal returns LiteralExpression:
	//	(
	//		'(' LiteralExpression ')' |
	//		RValue
	//	)
	//;
	//
	//enum BinOp returns Op:
	//	and = '&&' |
	//	or  = '||'
	//;
	//
	//enum NegationOp returns Op:
	//	neg = '!'
	//;
	//
	//enum CompOp returns Op:
	//	eq = '==' |
	//	ne = '!=' |
	//	lt = '<'  |
	//	gt = '>'  |
	//	le = '<=' |
	//	ge = '>='
	//;
	//
	//enum AddOp returns Op:
	//	plus  = '+' |
	//	minus = '-'
	//;
	//
	//enum MultiOp returns Op:
	//	times       = '*'  |
	//	modulo      = '%'  |
	//	intdivision = '//' |
	//	divideby    = '/'
	//;
	//
	//enum ExpOp returns Op:
	//	exp = '**'
	//;
	//
	//RValue:
	//	SingleLiteral   |
	//	SequenceLiteral |
	//	TupleLiteral    |
	//
	////	NodeRef         |
	////	MemberRef       |
	//	ConstantRef
	//;
	//
	//NodeRef:
	//	node = [Node|ID]
	//;
	//
	//MemberRef:
	////	(
	////		node = [Node|ID]
	////		'.'
	////	)?
	//	member = [LoopSentence|ID]
	//;
	//
	//ConstantRef:
	//	constantref = [Constant|ID]
	//;
	//
	//SingleLiteral:
	//	value = SingleLiteralDT
	//;
	//
	//SingleLiteralDT:
	//	BoolLiteral   |
	//	NumberLiteral |
	//	StringLiteral
	//;
	//
	//StringLiteral:
	//	STRING
	//;
	//
	//NumberLiteral:
	//	Integer   |
	//	Float     |
	//	SNotation |
	//	Imaginary
	//;
	//
	//Integer:
	//	INT |
	//	OCT |
	//	HEX |
	//	BIN
	//;
	//
	//Float:
	//	( INT '.' INT? )
	//	|
	//	( '.' INT )
	//;
	//
	//SNotation:
	//	( INT | Float )
	//	ExpConstant
	//	Sign?
	//	INT
	//;
	//
	//ExpConstant: 'e' | 'E' ;
	//
	//Sign: '+' | '-';
	//
	//Imaginary:
	//	( INT | Float )?
	//	ImaginaryConstant
	//;
	//
	//ImaginaryConstant: 'i' | 'j';
	//
	//BoolLiteral: 'true' | 'false';
	//
	//SequenceLiteral:
	//	SequenceLiteralPlain |
	//	SequenceLiteralSerie
	//;
	//
	//SequenceLiteralSerie:
	//	'[..'
	//		init = LiteralExpression
	//		'->'
	//		end  = LiteralExpression
	//		(
	//			','
	//			inc  = LiteralExpression
	//		)?
	//	']'
	//;
	//
	//SequenceLiteralPlain:
	//	{SequenceLiteralPlain}
	//	'['
	//		(
	//			items += LiteralExpression
	//			( ',' items += LiteralExpression )*
	//		)?
	//	']'
	//;
	//
	//TupleLiteral:
	//	{TupleLiteral}
	//	'('
	//		(
	//			items += TupleItem
	//			( ',' items += TupleItem )*
	//		)?
	//	')'
	//;
	//
	//TupleItem:
	//	name  = ID
	//	':'
	//	value = LiteralExpression
	//;
	//
	////terminal DEC returns ecore::EInt:     ('0'..'9')                  +;
	//terminal OCT returns ecore::EInt:     ('0'..'7')                  + 'o';
	//terminal HEX returns ecore::EInt: '0x'('0'..'9'|'A'..'F'|'a'..'f')+    ;
	//terminal BIN returns ecore::EInt:     ('0'..'1')                  + 'b';
	//
	//Block:
	//	{Block}
	//	'{'
	//		( '~' name = ID )?
	//		sentences += Sentence*
	//	'}'
	//;
	//
	//Noop:
	//	{Noop}
	//	name = 'noop'
	//;
	//
	//Pair:
	//	name  = ID
	//	'='
	//	value = STRING
	//;
	//
	//Constant:
	//	'constant'
	//	name  = ID
	//	type  = TypeRef
	//	'='
	//	value = LiteralExpression
	//;
	//
	//Multi:
	//	'multi'
	//	name     = ID
	//	'='
	//	op       = MultiOp?
	//	factor   = INT
	//	parent   = [Multi|ID]?
	//;
	//
	//Unit:
	//	DUnit |
	//	NUnit
	//;
	//
	//DUnit:
	//	'unit'
	//	name     = ID
	//	'='
	//	op       = MultiOp?
	//	factor   = INT
	//	multi    = [Multi|ID]?
	//	parent   = [Unit|ID]
	//;
	//
	//NUnit:
	//	'unit'
	//	name       = ID
	//	numbertype = NumberType
	//;
	//
	//Box:
	//	'box' name=ID
	//	'{'
	//		members += Member*
	//	'}'
	//;
	//
	//Shape:
	//	'shape'
	//	name = ID
	//;
	//
	//Member:
	//	name = ID
	//	type = TypeRef
	//;
	//
	//TypeRef:
	//	PlainTypeRef     |
	//	CompositeTypeRef
	//;
	//
	//PlainTypeRef:
	//	VoidTypeRef       |
	//	AutoTypeRef       |
	//	NumberTypeRef     |
	//	VisualTypeRef     |
	//	AuxTypeRef        |
	//	TypeAliasRef      |
	//	ShapeRef          |
	//	BoxRef            |
	//	UnitRef           |
	//	CollectionRef
	//;
	//
	//CompositeTypeRef:
	//	SequenceTypeRef   |
	//	TupleTypeRef      |
	//	SetTypeRef
	//;
	//
	//SequenceTypeRef:
	//	{SequenceTypeRef}
	//	'['
	//		type = TypeRef
	//	']'
	//;
	//
	//TupleTypeRef:
	//	{TupleTypeRef}
	//	'('
	//		(
	//			items += TupleTypeRefItem
	//			( ',' items += TupleTypeRefItem )*
	//		)?
	//	')'
	//;
	//
	//TupleTypeRefItem:
	//	name = ID
	//	':'
	//	type = TypeRef
	//;
	//
	//SetTypeRef:
	//	{SetTypeRef}
	//	'{'
	//		type = TypeRef
	//	'}'
	//;
	//
	//VoidTypeRef:
	//	name = 'void'
	//;
	//
	//AutoTypeRef:
	//	{AutoTypeRef}
	//	'auto'
	//;
	//
	//CollectionRef:
	//	collection = CollectionType '<' typeref = TypeRef '>'
	//;
	//
	//UnitRef:
	//	'in' unittype = [Unit|ID]
	//;
	//
	//BoxRef:
	//	'->' ref = [Box|ID]
	//;
	//
	//TypeAliasRef:
	//	ref = [TypeAlias|ID]
	//;
	//
	//AuxTypeRef:
	//	ref = AuxType
	//;
	//
	//ShapeRef:
	//	'~>' ref = [Shape|ID]
	//;
	//
	//NumberTypeRef:
	//	ref = NumberType
	//;
	//
	//VisualTypeRef:
	//	ref = VisualType
	//;
	//
	//enum NumberType:
	//	positive |
	//	natural  |
	//	integer  |
	//	rational
	//;
	//
	//enum VisualType:
	//	shape      |
	//	color      |
	//	angle      |
	//	size       |
	//	position   |
	//	texture
	//;
	//
	//enum AuxType :
	//	string     |
	//	bool
	//;
	//
	//TypeAlias:
	//	'alias'
	//	name = ID
	//	type = TypeRef
	//;
	//
	//enum CollectionType:
	//	set     |
	//	bag     |
	//	list    |
	//	graph   |
	//	single //trees, graphs, heaps, queues, stacks, ...?
	//;
	//
	//Stream:
	//	( name = 'stream' )?
	//	left = LStreamValue
	//	'<-'
	//	right = RStreamValue
	//;
	//
	//LStreamValue:
	//	OutputRef
	//;
	//
	//RStreamValue:
	//	InputRef         |
	//	LiteralExpression
	//;
	//
	//InputRef:
	//	{InputRef}
	//	'I'
	//;
	//
	//OutputRef:
	//	{OutputRef}
	//	'O'
	//;
	//
	//Invokation:
	//	module = ID//Module
	//	name = ID
	//	'{'
	//		( sentences += InvokationParam )*
	//	'}'
	//;
	//
	//InvokationParam:
	//	name = ID
	//	'<-'
	//	source = LiteralExpression
	//;
	//
	//Loop:
	//	'loop' 	
	//	it = (
	//		LoopFor
	//	)?
	//	name = ID
	//	'{'
	//		( sentences += LoopSentence )*
	//	'}'
	//;
	//
	//LoopSentence:
	//	name = ID
	//	type = TypeRef
	//	'<-'
	//	o = LiteralExpression
	//	(
	//		'<-'
	//		i = LiteralExpression
	//	)?
	//;
	//
	//LoopFor:
	//	( 'for' SequenceLiteral )
	//;
	//
	//Factory:
	//	'factory'
	//	name = ID
	//	type = TypeRef
	//;
	//
	//File:
	//	'file'
	//	name = ID
	//	(
	//		( isinput ?= '<-' ) |
	//		'->'
	//	)
	//	path = STRING
	//;
	//
	//Canvas:
	//	'canvas'
	//	name = ID
	//	'{'
	//		( properties += Pair ';' )*
	//	'}'
	//;
	// * / //terminal ID: ('a'..'z'|'A'..'Z');
	////terminal DATE: ('0'..'9')('0'..'9')('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9');
	////enum eConstant:
	////	PI   |
	////	G    |
	////	e    |
	////	A    |
	////	
	////	zero
	////;
	////
	////enum DecimalUpMulti:
	////	I    |//24
	////	Z    |//21
	////	E    |//18
	////	P    |//15
	////	T    |//12
	////	G    |//9
	////	M    |//6
	////	K    |//3
	////	H    |//2
	////	D    |//1
	////	
	////	regular
	////;
	////	
	////enum DecimalDownMulti:
	////	d    |//-1
	////	c    |//-2
	////	m    |//-3
	////	u    |//-6 ¬µ
	////	n    |//-9
	////	p    |//-12
	////	f    |//-15
	////	a    |//-18
	////	z    |//-21
	////	y    |//-24
	////
	////	regular
	////;
	////
	////enum NonDecimalMulti:
	////	dozen      |//12
	////	twelve     |//12
	////	sixty      |//60
	////	twentyfour |//24
	////	
	////	regular
	////;
	////
	////enum TimeDerivedUnits:
	////	minute    |
	////	hour      |
	////	day       |
	////	month     |
	////	year      |
	////	century   |
	////	millenium
	////;
	////
	////enum eUnit:
	////	second |
	////	meter  |
	////	gram   |
	////	newton |
	////	joule  |
	////	watt   |
	////	rad    |
	////	kelvin |
	////	
	////	units
	////;
	////
	////enum
	////	time    |
	////	date    |
	////	duration|
	////	
	////	geopos  |
	////	
	////	auto
	////;
	////
	////Source:
	////	'source' name=ID
	////	'{'
	////		( properties += Pair ';' )*
	////	'}'
	////;
	////
	////SourceRef:
	////	'^' ref=[Source|ID]
	////;
	////Model:
	////	(imports += Import)*
	////	(elements += Invokation)*
	////;
	////	
	////Import:
	////	'import' name=ID ';'
	////;
	////
	////Invokation:
	////	name=ID '(' (pars += Par)* ')'
	////;
	////
	////Par:
	////	value=STRING
	////;
	////
	////Program :
	////		'main' name = VARNAME content = Block
	////;
	////
	////Block :
	////		'{' ( sentences += Sentence )+ '}' |
	////		Sentence
	////;
	////
	////Sentence : ( Var | Asg | Print ) ';' ;
	////
	////Var : 'var' name = VARNAME ( init ?= '=' content = Exp ) ?;
	////
	////Asg : left = [Var] '=' right = Exp;
	////
	////Print : 'print' Exp;
	////
	////Exp :
	////		'(' includes = Exp ')'
	////;
	////
	////BinExp returns Exp :
	////		left = Exp operator = sumop right = Exp
	////;
	////
	////LitExp returns Exp :
	////		ref = VARNAME |
	////		val = INTEGER
	////;
	////
	////enum sumop returns BinOperator:
	////		ADD = '+' |
	////		SUB = '-'
	////;
	////		
	////enum mulop returns BinOperator:
	////		MUL = '*' |
	////		DIV = '/' |
	////		MOD = '%'
	////;
	////
	////terminal VARNAME : ('a'..'z')('a'..'z'|'_'|'0'..'9')*;
	////
	////terminal INTEGER : ('0'..'9') + ;
	////
	//////enum monop returns Op:
	//////		INV = '-' | INV = 'inv' |
	//////		LN  = '~' | LN  = 'ln'
	//////;
	////
	////// terminal FLOAT returns ecore::EFloat : INT '.' UINT? ( ( 'e' | 'E' ) INT )? ;
	////
	////
	////	
	//Output:
	//	name=STRING ":" type=[TypeDecl];
	public OutputElements getOutputAccess() {
		return (pOutput != null) ? pOutput : (pOutput = new OutputElements());
	}
	
	public ParserRule getOutputRule() {
		return getOutputAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
