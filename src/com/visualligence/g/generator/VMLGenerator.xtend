/*
 * generated by Xtext
 */
package com.visualligence.g.generator

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.parser.antlr.splitting.simpleExpressions.NumberLiteral
import java.util.Date
import com.visualligence.g.vML.Box
import com.visualligence.g.vML.Constant
import com.visualligence.g.vML.ConstantRef
import com.visualligence.g.vML.Factory
import com.visualligence.g.vML.InputRef
import com.visualligence.g.vML.Module
import com.visualligence.g.vML.Operation
import com.visualligence.g.vML.Sentence
import com.visualligence.g.vML.SequenceLiteralPlain
import com.visualligence.g.vML.SequenceLiteralSerie
import com.visualligence.g.vML.ShapeRef
import com.visualligence.g.vML.TupleLiteral
import com.visualligence.g.vML.UnaryOperation
import com.visualligence.g.vML.TypeRef
import com.visualligence.g.vML.NumberTypeRef
import com.visualligence.g.vML.SequenceTypeRef
import com.visualligence.g.vML.BoxRef
import com.visualligence.g.vML.VoidTypeRef
import com.visualligence.g.vML.LiteralExpression
import com.visualligence.g.vML.Stream
import com.visualligence.g.vML.LStreamValue
import com.visualligence.g.vML.RStreamValue
import com.visualligence.g.vML.OutputRef
import com.visualligence.g.vML.AuxTypeRef
import com.visualligence.g.vML.AuxType
import com.visualligence.g.vML.Op
import com.visualligence.g.vML.SingleLiteral

class VMLGenerator implements IGenerator {

	def dispatch id( Object o )'''v_«o.hashCode»'''
	def dispatch id( Constant k )'''v_k_«k.name»'''

	def base( String uri )'''«uri.substring(0,uri.indexOf('.'))»'''

	def cName( Resource r ){
		return r.URI.lastSegment.base
	}
	
	def pName( Resource r ){
		return "com/visualligence/gen/" + r.cName + "/"
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		var Module m = ( resource.contents.head as Module )

		try{
			var txt = m.toTxt
			fsa.generateFile( resource.pName + resource.cName + ".dump.txt", txt )

			var java = m.toJavaCode
			fsa.generateFile( resource.pName + resource.cName + ".java", java )

			for( Sentence s : m.sentences.filter( e | e instanceof Box )){
				var java_box = (s as Box).toJavaCodeBox( m )
				var java_box_filename = resource.pName + (s as Box).name + ".java"
				fsa.generateFile( java_box_filename, java_box )
			}
		} catch (Exception e){
			var error = "/*" + e + "*/"
			fsa.generateFile( resource.pName + resource.cName + ".java", error )
		}
	}

	def automark()'''File autogenerated by VML at «new Date()»'''

	def toJavaCode( Module m )'''
		/* Module «m.name»
		 *
		 * «automark»
		 *
		 * Author: «m.author?.toString»
		 * More info: «m.link?.toString»
		 * Creation date: «m.creation?.toString»
		 *
		 */

		package com.visualligence.gen.«m.name»;
		
		import com.visualligence.g.vm.core.*;
		import com.visualligence.g.vm.util.*;
		import com.visualligence.g.vm.types.*;
		import com.visualligence.g.vm.streams.*;
		import com.visualligence.g.vm.constants.*;
		import com.visualligence.g.vm.sequences.*;
		import com.visualligence.g.vm.factories.*;
		import com.visualligence.g.vm.operations.*;
		import com.visualligence.g.vm.expressions.*;
		import com.visualligence.g.vm.comparators.*;

		«FOR i : m.imports»
		import com.visualligence.gen.«i.importURI.base».*;
		«ENDFOR»
		«FOR s : m.sentences»
			«s.toJavaCodePrev»
		«ENDFOR»

		public class «m.eResource.cName» extends Node<«m.inputtype?.toType»,«m.outputtype?.toType»>{

			public static void main(String[] args) {
				System.out.println("Content-type: text/plain;\n");
				long start = System.currentTimeMillis();
				new «m.eResource.cName»().run();
				long end = System.currentTimeMillis();
				System.err.println((end-start) + "ms.");
			}

			public void run( StreamInput<«m.inputtype?.toType»> sin, StreamOutput<«m.outputtype?.toType»> sout )
			{
				«FOR s : m.sentences»
					«s.toJavaCodeDecl»
				«ENDFOR»
				«FOR s : m.sentences»
					«s.toJavaCodeUsage»
				«ENDFOR»
				sout.exec();
			}
			
		}
	'''

	def toJavaCodeBox( Box b, Module m )'''
		/* Box «m.name»
		 *
		 * «automark»
		 *
		 */

		package com.visualligence.gen.«m.name»;
		
		import com.visualligence.g.vm.core.*;
		import com.visualligence.g.vm.util.*;
		import com.visualligence.g.vm.types.*;
		import com.visualligence.g.vm.streams.*;
		import com.visualligence.g.vm.constants.*;
		import com.visualligence.g.vm.sequences.*;
		import com.visualligence.g.vm.factories.*;
		import com.visualligence.g.vm.operations.*;
		import com.visualligence.g.vm.expressions.*;
		import com.visualligence.g.vm.comparators.*;

		public class «b.name» extends VTuple{
			«FOR f : b.members»
				«f.type.toType» «f.name»;
			«ENDFOR»
		}
	'''

	def dispatch toType( TypeRef tr )'''«tr.id»'''
	def dispatch toType( NumberTypeRef nt )'''VScalar'''
	def dispatch toType( SequenceTypeRef sq )'''VSequence<«sq.type.toType»>'''
	def dispatch toType( BoxRef br )'''«br.ref.name»'''
	def dispatch toType( VoidTypeRef v )'''VVoid'''
	def dispatch toType( AuxTypeRef at ){
		switch( at.ref ){
			case AuxType::BOOL:   "VBool"
			case AuxType::STRING: "VString"
		}
	}

	def dispatch toJavaCodePrev( EObject e )''''''
	def dispatch toJavaCodeDecl( EObject e )''''''
	def dispatch toJavaCodeUsage( EObject e )'''
		// «e.^class.name» - «e.id» - «e.toTxtSig»
	'''

	def dispatch toLeftRef( LStreamValue lsv, String right )'''//«lsv.id» <- «right»;'''
	def dispatch toLeftRef( OutputRef o, String right )'''sout.attach(«right»);'''

	def dispatch toRightRef( RStreamValue rsv )'''«rsv.id»'''
	def dispatch toRightRef( ConstantRef kref )'''«kref.constantref.id»'''
	def dispatch toRightRef( InputRef i )'''sin'''

	def dispatch toJavaCodeDecl( Stream s )'''
		«s.left.toJavaCodeDecl»
		«s.right.toJavaCodeDecl»
	'''

	def dispatch toJavaCodeUsage( Stream s )'''
		«s.left.toLeftRef(s.right.toRightRef.toString)»
	'''
	
	def dispatch toJavaCodeDecl( Operation oper ){
		//oper.left?.toJavaCodeDecl
		//oper.right?.toJavaCodeDecl
		var opt = switch( oper.op ){
			case Op::PLUS: "Plus"
			case Op::MINUS: "Minus"
			case Op::TIMES: "Times"
			case Op::DIVIDEBY: "DivideBy"
			case Op::INTDIVISION: "IntDivision"
			case Op::MODULO: "Modulo"
		}
		'''«opt»<VVoid> «oper.id» = new «opt»<VVoid>(«oper.left?.id»,«oper.right?.id»);'''
	}

	def dispatch toJavaCodeDecl( UnaryOperation oper ){
		//oper.right?.toJavaCodeDecl
		var opt = switch( oper.op ){
			case Op::PLUS: "Plus"
			case Op::MINUS: "Minus"
			case Op::TIMES: "Times"
			case Op::DIVIDEBY: "DivideBy"
			case Op::INTDIVISION: "IntDivision"
			case Op::MODULO: "Modulo"
		}
		'''«opt»<VVoid> «oper.id» = new «opt»<VVoid>(«oper.right?.id»);'''
	}

	def dispatch toJavaCodeDecl( SingleLiteral sl )'''
		VScalar «sl.id» = new VScalar(«sl.value»);
	'''

	def dispatch toJavaCodeDecl( Constant c )'''
		«c.value.toJavaCodeDecl»
		Constant<«c.type.toType»> «c.id» = new Constant<«c.type.toType»>(«c.value.id»);
	'''

	def dispatch toJavaCodeDecl( Factory f )'''
		FFactory f«f.hashCode» = new FFactory("«f.type.toTxtSig»");
	'''

	def dispatch toStreamInputCode( InputRef i, int h )'''
		Object a«h» = in.next();
	'''

	def dispatch toStreamInputCode( ConstantRef c, int h )'''
		Object a«h» = c«c.constantref.hashCode»;
	'''

	def toLiteral( SequenceLiteralPlain t, String c )'''
		«FOR i : t.items»
			«c».add("«i.id»");
		«ENDFOR»
	'''

	def toTxtSig( EObject e )'''«e.eClass.name» «e.toString.replaceFirst('[^(]*','')»'''
	def dispatch toTxt( Void n )''''''
	def dispatch toTxt( ConstantRef c )'''k(«c.constantref.name»)'''
	def dispatch toTxt( Operation o )'''(«o.left.toTxt»)«o.op»(«o.right.toTxt»)'''
	def dispatch toTxt( UnaryOperation o )'''«o.op»(«o.right.toTxt»)'''
	def dispatch toTxt( ShapeRef s )'''~> «s.ref.name»'''
	def dispatch toTxt( NumberLiteral nl )'''«nl.value»'''
	def dispatch toTxt( TupleLiteral t )'''(«FOR i : t.items» «i.toTxtSig» ,«ENDFOR»)'''
	def dispatch toTxt( SequenceLiteralSerie t )'''[«t.init.toTxtSig»->«t.end.toTxtSig»,>«t.inc.toTxtSig»]'''
	def dispatch toTxt( SequenceLiteralPlain t )'''[«FOR i : t.items» «i.toTxtSig» ,«ENDFOR»]'''

	def dispatch toTxt( EObject m )'''
	«m.toTxtSig»
		«IF m.eCrossReferences.size + m.eContents.size > 0»
			«FOR ref : m.eCrossReferences»
			-> «ref.toTxtSig»
			«ENDFOR»
			«FOR child : m.eContents»
			<> «child.toTxt»
			«ENDFOR»
		«ENDIF»
	'''
}
